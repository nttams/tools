<h3>GOLANG</h3>
<p>hi</p>
<hr />
<h3>NOTES</h3>
<p>Test-driven development (TDD)</p>
<hr />
<h3>BOOKS</h3>
<p>tôi nói gì khi nói về chạy bộ</p>
<hr />
<h3>VSCODE</h3>
<p>workbench.action.terminal.focus<br />
workbench.action.focusActiveEditorGroup</p>
<p>"editor.quickSuggestions": {<br />
    "other": false,<br />
    "comments": false,<br />
    "strings": false<br />
},</p>
<p>addin: LiveServer</p>
<hr />
<h3>LINUX</h3>
<p>rename files: for i in lessEnglish_Chapter*;do mv "$i" "${i/lessEnglish_Chapter/''}"; done;</p>
<p>Ctrl * \: split window<br />
Ctrl * tab: switch windows<br />
Ctrl * shift * O: explore outline</p>
<hr />
<h4>STATIC IPs</h4>
<p>network:<br />
    version: 2<br />
    renderer: networkd<br />
    ethernets:<br />
    eno1:<br />
        dhcp4: false<br />
        dhcp6: false<br />
        addresses:<br />
            - 192.168.1.10/24<br />
        routes:<br />
            - to: default<br />
            via: 192.168.1.1<br />
        nameservers:<br />
            addresses: [8.8.8.8,8.8.4.4]</p>
<hr />
<h3>GITHUB</h3>
<p>git config --get remote.origin.url<br />
git push -u origin second_branch</p>
<h4>create a new repository on the command line</h4>
<p>echo "# test_git" &gt;&gt; README.md<br />
git init<br />
git add README.md<br />
git commit -m "first commit"<br />
git branch -M main<br />
git remote add origin https://github.com/nttam000/test_git.git<br />
git push -u origin main  </p>
<h4>push an existing repository from the command line</h4>
<p>git remote add origin https://github.com/nttam000/test_git.git<br />
git branch -M main<br />
git push -u origin main</p>
<hr />
<h4>GIT CACHING</h4>
<p>git config --global credential.helper cache</p>
<hr />
<h3>HASHING</h3>
<p>Characteristics of a good hash function</p>
<ul>
<li>The hash value is fully determined by the data being hashed.</li>
<li>The hash function uses all the input data.</li>
<li>The hash function "uniformly" distributes the data across the entire set of possible hash values.</li>
<li>The hash function generates very different hash values for similar strings.</li>
</ul>
<hr />
<h3>C++</h3>
<ul>
<li>When using c+* template, remember to add implemenation for that template, otherwise you wil get "undefined reference to..."</li>
</ul>
<hr />
<h3>RUST</h3>
<h4>Tips</h4>
<p>use Vec<u8> as buffer for network reading rather than array</p>
<h4>Expression</h4>
<ul>
<li>Calling a function is an expression.</li>
<li>Calling a macro is an expression.</li>
<li>A new scope block created with curly brackets is an expression</li>
<li>if is an expression</li>
</ul>
<h4>Stack &amp; Heap</h4>
<p>All data stored on the stack must have a known, fixed size. Data with an unknown size at compile time or a size that might change must be stored on the heap instead.<br />
There’s a design choice that’s implied by this: Rust will never automatically create “deep” copies of your data. Therefore, any automatic copying can be assumed to be inexpensive in terms of runtime performance.</p>
<h4>Here are some of the types that implement Copy:</h4>
<ul>
<li>All the integer types, such as u32.</li>
<li>The Boolean type, bool, with values true and false.</li>
<li>All the floating point types, such as f64.</li>
<li>The character type, char.</li>
<li>Tuples, if they only contain types that also implement Copy. For example, (i32, i32) implements Copy, but (i32, String) does not.</li>
</ul>
<h4>Ownership passing to function</h4>
<p>datatype does not implement COPY ()
--&gt; pass whole stack value (it may contain pointer to heap memory that actually contain data)
--&gt; when the variable goes out of scope, drop() function is called
--&gt; if variable is already moved (e.g to a function), nothing happens when that variable goes out of scope. It is not valid anymore
--&gt; drop() and copy() can not be implemented together. Only one of them.
--&gt; Use reference instead if you don't want to give up ownership of a variable to a function</p>
<p>datatype does implement COPY () --&gt; pass whole stack value</p>
<h4>Reference</h4>
<ul>
<li>Unlike a pointer, a reference is guaranteed to point to a valid value of a particular type</li>
<li>You can have only ONE mutable reference to a particular piece of data at a time</li>
</ul>
<h4>Debug info</h4>
<ul>
<li>println!("{:?}", rect);</li>
<li>println!("{:#?}", rect);</li>
<li>with #[derive(Debug)] before the struct defination</li>
</ul>
<h4>Function and method</h4>
<p>Associated functions that aren’t methods are often used for constructors that will return a new instance of the struct.</p>
<h4>String</h4>
<p>let s1 = String::from("tic");<br />
let s2 = String::from("tac");<br />
let s3 = String::from("toe");<br />
let s = format!("{}-{}-{}", s1, s2, s3);</p>
<h4>Error handling</h4>
<p>Rust groups errors into two major categories:
* recoverable
* unrecoverable</p>
<p>Rust doesn’t have exceptions.<br />
<em> The type Result<T, E> for recoverable errors<br />
</em> The panic! macro that stops execution when the program encounters an unrecoverable error.  </p>
<p>Result.up_wrap: print the ERR message<br />
Result.expect: print your own message<br />
--&gt; using unwrap in multiple places, it can take more time to figure out exactly which unwrap is causing the panic because all unwrap calls that panic print the same message.</p>
<h4>Trait</h4>
<p>pub fn notify(item1: &amp;impl Summary, item2: &amp;impl Summary) {<br />
}<br />
//If we wanted to force both parameters to have the same type, --&gt;<br />
pub fn notify<T: Summary>(item1: &amp;T, item2: &amp;T) {<br />
}</p>
<hr />
<h3>INTERVIEW</h3>
<ul>
<li>Prepare:</li>
<li>Tell me about yourself</li>
<li>What are you strengths and weaknesses</li>
<li>Do you have any question about us?</li>
<li>Do mock interviews</li>
<li>Practise algorithmns on paper</li>
<li>HASH TABLE</li>
<li>Remember the key information from the interviewers --&gt; write them down: Big, Not special case, Use real, valid number, string</li>
</ul>
<h4>Steps</h4>
<ul>
<li>Listen</li>
<li>Example</li>
<li>Bruce force</li>
<li>Optimize</li>
<li>Trust your brain, let your brain solve the problem naturally, and then reverse-engineer it.</li>
<li>Start with simple problem, solve it, then adapt it to orginal problem</li>
<li>Base case first (read CTCI)</li>
<li>Walk through</li>
<li>Implement: Good variable names</li>
<li>Test</li>
</ul>
<hr />
<h3>Sayings</h3>
<ul>
<li>Write code that is easy to delete, not easy to extend.</li>
<li>done is better than perfect</li>
<li>Impatience makes smart people do stupid things</li>
<li>Test ideas by experiment and observation. Build on those ideas that pass the test, reject the ones that fail, follow the evidence where ever it leads and question everything.</li>
</ul>
<hr />
<h3>VIM</h3>
<p>:g/^$/d     delete all empty lines</p>
<p>~/.config/nvim/init.vim</p>
<hr />
<h3>DATA STRUCTURES</h3>
<h4>Linked list</h4>
<ul>
<li>Good for inserting and removing element</li>
<li>Not good for accessing and sorting</li>
</ul>
<h4>Binary tree</h4>
<ul>
<li>Good for ordering</li>
</ul>
<h4>Hash table</h4>
<ul>
<li>Very important</li>
</ul>
<h4>Tree</h4>
<ul>
<li>Balanced or NOT</li>
<li>Binary search tree or NOT</li>
<li>Equality (duplicated or NOT)</li>
<li>Please be COMFORTABLE with traversal binary tree (in-order, post-order, pre-order)</li>
</ul>
<h4>Graph</h4>
<ul>
<li>BFS: breadth first search: is NOT recursive</li>
</ul>
<hr />
<h3>SOFTWARES</h3>
<ul>
<li>VirtualBox</li>
<li>Wireshark</li>
<li>NeoVim</li>
<li>PostMan</li>
<li>VsCode</li>
<li>Notepad++</li>
<li>FoxitReader</li>
<li>git, net-tools, htop, nload</li>
<li>MobaXTerm</li>
<li>Hercules</li>
</ul>
<hr />
<h3>LIST OF MISTAKES</h3>
<ul>
<li>Forget edge cases</li>
<li>Code before think</li>
</ul>
<hr />
<h3>File converter</h3>
<ul>
<li>ffmpeg -i input.mkv -codec copy output.mp4  </li>
<li>for i in <em>.mkv; do ffmpeg -i "$i" -codec copy  "${i%.</em>}.mp4"; done</li>
</ul>
<hr />
<h3>APACHE2</h3>
<p>You'll have to edit<br />
<em> /etc/apache2/sites-available/000-default.conf: to change the document root of apache (from /var/www/html/ to whatever you want)<br />
</em> /etc/apache2/apache2.conf: to grant permission  </p>
<hr />
<h1>The end</h1>
<p><link rel="stylesheet" href="styles.css">
<link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css"></p>